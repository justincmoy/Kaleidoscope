/* -*- mode: c++ -*-
 * Kaleidoscope-SimpleChords -- Simple chording support
 * Copyright (C) 2022  Evan Danaher
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation, version 3.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program. If not, see <http://www.gnu.org/licenses/>.
 */

/*
 * This implements a simple (but imperfect) notion of "chording", where mutiple keys can be quickly pressed to
 * result in a different action being taken.  This is similar to MagicCombo, but does not also send the
 * individual keypresses; this makes it useful for applying to non-modifier keys.  (E.g., mapping A and S to
 * escape in MagicCombo would result in AS<escape>, while here, it would result in simply <escape>).
 *
 * This is a simplified model in which all keys in the chord must be pressed not only within the timeout, but
 * also consecutively with no other keys in between.  (E.g., if "AS" is a chord, pressing "ADS" would not
 * activate the chord, regardless of timing).  (This is not *quite* true - if a subset of a chord is pressed,
 * and then releasing a key results in matching another chord, that will still match.  E.g., if AS and ASDF
 * are chords, pressing ADS and releasing D will match AS.  However, given expected timeouts, this case is
 * unlikely and likely harmless.)
 *
 * Further, as soon as a chord is detected, it is activated, and those keys cannot be used in other chords.
 * (For example, if AS, AD and ASD are all define chords, pressing ASD will trigger AS, consume them, and then
 * press D, while ADS would similarly trigger AD and then press S, while SDA will produce only ASD, since it
 * is the only chord to fully match at any point.
 *
 * So avoid overlapping chords that may be pressed simultaneously, though cases such as QA and AZ are likely
 * fine, as it's unlikely that both would be pressed simultaneously.
 *
 * Note also that if the timeout is zero (no timeout), keys in chords will not be sent until they are released
 * or a non-chord key is pressed.  This is similar to, e.g., the Twiddler3, and may be useful in certain
 * special cases.
 *
 * Implementation:
 *
 * Intuitively, on a keypress, if it's part of a chord, delay it until either:
 *
 *   - a timeout is reached (send the keypress)
 *   - the chord is completed (replace the first key with the chord, and drop following keypresses)
 *   - a key that is not part of the chord is pressed (send the keypress, followed by the other key)
 *   - the key is released (send the keypress, followed by the release)
 *
 * Since a key can be part of multiple chords, chords can contain multiple keys, and keys can be released in
 * any order, this is implemented by tracking a queue of keys that can potentially be part of a chord.
 *
 * So more precisely:
 *
 * - On a keypress, we logically add the key and its timestamp to the end of the queue, and check for cases:
 *   - If the queue matches a chord, we send the chord and empty the queue.
 *   - If the queue is not a subset of any chord, remove the first key in the queue, send it, and repeat.
 * - On a keyrelease, we remove the key from the queue
 *   - If the queue now matches a chord, we send the chord and empty the queue.
 *     (E.g., if ASDF is a chord, and so is AS, pressing ADS and then releasing D would trigger this.  This
 *     is a bit odd, but likely harmless and simplifies implementation.)
 *   - The queue was previously a subset of a chord, so it still is.
 * - If the first key in the queue times out, we treat it as if that key was released, sending it and checking
 *   the remainder of the queue for chords.
 *
 *
 * Note that this is somewhat limiting - most cases are probably handled, but the TextBlade uses ZX, XC, and
 * CV as modifiers - if ZX is bound to control, and XC to shift, pressing ZXC should result in both control
 * and shift being pressed, but that is not possible with this plugin.
 *
 * However, handling that is significantly more complex, and this likely handles most cases.  Hopefully a
 * future non-simple chords plugin will allow for that.
 *
 * Artificial limitations:
 * - A chord can have at most five keys in it
 * - If more than ten keys are pressed simultaneously, the oldest ones will be treated as timed out regardless
 *   of timing.
 */

#include <Kaleidoscope-SimpleChords.h>
#include <Kaleidoscope-FocusSerial.h>
#include "kaleidoscope/keyswitch_state.h"
#include "kaleidoscope/Runtime.h"
#include "kaleidoscope/device/key_indexes.h"

#include "Kaleidoscope-Macros.h"

#define CHORD_TIMEOUT 24
#define QUEUE_LEN 10

namespace kaleidoscope {
namespace plugin {

SimpleChords::Chord chords[] = {
  {
    .length = 2,
    .keys = {Key_F, Key_R},
    .action = Key_Tab
  }, /*{
    .length = 2,
    .keys = {Key_V, Key_F},
    .action = Key_Minus
  }, {
    .length = 2,
    .keys = {Key_Z, Key_X},
    .action = Key_LeftGui
  }, {
    .length = 2,
    .keys = {Key_X, Key_C},
    .action = Key_LeftAlt
  }, {
    .length = 2,
    .keys = {Key_D, Key_C},
    .action = Key_RightAlt
  }, {
    .length = 2,
    .keys = {Key_C, Key_V},
    .action = Key_LeftControl
  }, {
    .length = 2,
    .keys = {Key_Slash, Key_Period},
    .action = Key_LeftGui
  }, {
    .length = 2,
    .keys = {Key_Period, Key_Comma},
    .action = Key_LeftAlt
  }, {
    .length = 2,
    .keys = {Key_Comma, Key_M},
    .action = Key_LeftControl
  }, {
    .length = 2,
    .keys = {Key_K, Key_Comma},
    .action = Key_RightAlt
  }, {
    .length = 2,
    .keys = {Key_J, Key_M},
    .action = Key_Escape
  }, {
    .length = 2,
    .keys = {Key_Backtick, Key_B},
    .action = M(2)
  }*/};


const int nchords = sizeof(chords) / sizeof(chords[0]);

queueItem queued_events_[QUEUE_LEN];

EventHandlerResult SimpleChords::onSetup() {
  nqueued_events_ = 0;

  return EventHandlerResult::OK;
}

void removeKeyAt(int index) {
    ::Focus.send(F("Removing queued key at index"), index, "\r\n");
}

void SimpleChords::queueEvent(KeyEvent &event) {
  if (nqueued_events_ == QUEUE_LEN) {
    // TODO: Drop the first element from the queue instead of this one
    return;
  }
  ::Focus.send(F("queueing event at index", nqueued_events_, "\r\n");
  queued_events_[nqueued_events_].event = event;
  queued_events_[nqueued_events_].time = Runtime.millisAtCycleStart();
  nqueued_events_++;
}

void SimpleChords::clearQueue() {
  nqueued_events_ = 0;
}

void SimpleChords::sendChord(int index) {
  clearQueue
}

void SimpleChords::checkChords() {
  int c, i, j;
  
  for (int c = 0; c < nchords; c++) {
    // An exact match has to be the same length
    if (chords[c].length != nqueued_events_)
      continue;
    for (int i = 0; i < nqueued_events_; i++) {
      for (int j = 0; i < nqueued_events_; i++)
        if(chords[c].keys[i] == queued_events_[j].event.key)
          break;
      // The key wasn't found in the queue; abort.
      if (j == nqueued_events_)
        break;
    }

    // No key wasn't found, so the queue matches!
    if (i == nqueued_events_) {
      sendChord(i);
    }
  }
}

EventHandlerResult SimpleChords::afterEachCycle() {
  while (nqueued_events_ > 0 && queued_events_[0].time)
    removeKeyAt(0);

  return EventHandlerResult::OK;
}

EventHandlerResult SimpleChords::onKeyswitchEvent(KeyEvent &event) {
  const uint8_t key_state = event.state;

  uint8_t i, j;

  if (event_tracker_.shouldIgnore(event))
    return EventHandlerResult::OK;

  if (KeyIsPressed(event.state)) {
    // Check if the key is in any chords
    // Note: This could be combined with the checking for activated chords, but KISS.
    for (int i = 0; i < nchords; i++) {
      for (int j = 0; j < chords[i].length; i++)
        if (chords[i].key[j] == event.key)
          break;
      // If the new key isn't in the chord, it's not going to be relevant.
      if (j != chords[i].length)
        break;
    }

    if(i != nchords) {
      queueEvent(event);
      checkChords();
      return EventHandlerResult::ABORT;
    }
  } else  {

  }

  return ret;
}

}
}

kaleidoscope::plugin::SimpleChords SimpleChords;
